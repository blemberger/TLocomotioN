import numpy as np
import matplotlib.pyplot as plt


numsegments = 3
cyclenum = 4
initsize = 0.1
initvariance = 0.05
projscaling = 0.2


epsilon = .5 # >0, <delta/(1+delta)
delta = 2 # >0
theta = 1 # >0

totaltime = 15
timestep = 0.005


netparams = [epsilon, delta, theta]
segparams = [numsegments, cyclenum, initsize, initvariance, netparams]
timeparams = [timestep, totaltime]



class Segment():
    def __init__(self, cyclenum, netparams):
        self.cyclenum = cyclenum
        self.netparams = netparams
        self.epsilon = netparams[0]
        self.delta = netparams[1]
        self.theta = netparams[2]

        self.rates = np.zeros([cyclenum])


    def nonneg(self):
        self.rates = [max(r, 0) for r in self.rates]

    def rand_initcondit(self, size, variance):
        self.rates = np.random.normal(loc=size, scale=variance, size=cyclenum)
        self.nonneg()




class Simulation():
    def __init__(self, segparams, timeparams):

        self.numsegments = segparams[0]
        self.cyclenum = segparams[1]
        self.init_size = segparams[2]
        self.init_variance = segparams[3]
        self.netparams = segparams[4]

        self.epsilon = self.netparams[0]
        self.delta = self.netparams[1]
        self.theta = self.netparams[2]

        self.timestep =  timeparams[0]
        self.totaltime = timeparams[1]
        self.stepnum = int(self.totaltime/self.timestep)
        self.timeaxis = np.arange(0, self.totaltime, self.timestep)

        self.ratehistories = np.zeros([self.numsegments, self.cyclenum, self.stepnum])

        self.segments = []
        for i in range(self.numsegments):
            self.segments.append(Segment(self.cyclenum, self.netparams))
            self.segments[-1].rand_initcondit(self.init_size, self.init_variance)
            self.ratehistories[i,:,0] = self.segments[-1].rates[:].copy()

        self.stepcount = 1

        
    def step(self):
        for i in range(self.numsegments):
            newrates = self.segments[i].rates[:].copy()
            ratechange = np.zeros([self.cyclenum])
            for a in range(self.cyclenum):
                input = 0
                input += self.theta
                ratechange[a] += -newrates[a]
                input += -(1-self.epsilon)*newrates[(a+1)%self.cyclenum]
                for b in range(self.cyclenum):
                    if b != a:
                        if b != (a+1)%self.cyclenum:
                            input += -(1+self.delta)*newrates[b]

                for j in range(self.numsegments):
                    otherrates = self.segments[j].rates[:].copy()
                    if i != j:
                        for b in range(self.cyclenum):
                            if (j-1)%self.numsegments == i:
                                if b == a:
                                    w = -(1-self.epsilon)
                                else:
                                    w = -(1+self.delta)*0
                            else: w = -(1+self.delta)
                            input += projscaling*w*otherrates[b]

                input = max(0, input)
                ratechange[a] += input
                ratechange[a] = ratechange[a]*self.timestep
            
            newrates = [newrates[a] + ratechange[a] for a in range(self.cyclenum)]
            self.ratehistories[i, :, self.stepcount] = newrates[:]
            self.segments[i].rates = newrates
        self.stepcount += 1

    def run(self):
        while self.stepcount*self.timestep < self.totaltime:
            self.step()

    def plot(self):
        fig, axs = plt.subplots(self.numsegments, 1)
        for i in range(self.numsegments):
            for a in range(self.cyclenum):
                axs[i].plot(self.timeaxis[:], self.ratehistories[i,a,:], alpha=0.7)
                axs[i].grid(True)
                for t in range(int(self.stepnum/10), self.stepnum-1):
                    if self.ratehistories[i,a,t] > self.ratehistories[i,a,t-1]:
                        if self.ratehistories[i,a,t] > self.ratehistories[i,a,t+1]:
                            axs[i].vlines(x=t*self.timestep, color='black', ymin=0, ymax=0.5, linewidth=1.5)
        
        fig.tight_layout()
        plt.savefig('TLocNplot.png')


S = Simulation(segparams=segparams, timeparams=timeparams)
S.run()
S.plot()